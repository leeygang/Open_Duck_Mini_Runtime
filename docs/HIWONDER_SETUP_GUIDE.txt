================================================================================
HIWONDER HTD-45H SERVO SETUP GUIDE
Complete step-by-step instructions for configuration and integration
================================================================================

TABLE OF CONTENTS
-----------------
1. Understanding the Hardware Setup
2. Where to Run Scripts (PC vs Raspberry Pi)
3. Phase 1: Initial Setup on PC
4. Phase 2: Integration on Raspberry Pi
5. Port Names Reference
6. Quick Test Commands
7. Troubleshooting
8. Recommendations

================================================================================
1. UNDERSTANDING THE HARDWARE SETUP
================================================================================

Question: Does hiwonder_hwi control servo through the board or directly?

Answer: THROUGH THE BOARD - The hiwonder_hwi.py sends commands to servos
VIA the Hiwonder Bus Servo Control Board (Serial Bus Servo Tester Board).

Hardware Architecture:
----------------------
    Computer/Raspberry Pi
        ↓ (USB cable)
    USB-to-TTL Adapter (CP2102, FT232, CH340, etc.)
        ↓ (Serial: TX, RX, GND wires)
    Hiwonder Bus Servo Control Board (serial pins)
        ↓ (Servo connectors, daisy-chained)
    Servo 1 (ID 100) → Servo 2 (ID 101) → Servo 3 (ID 102) ...
        ↓ (External 6-8.4V power supply)

Important Connection Detail:
-----------------------------
⚠️ The Hiwonder Bus Servo Control Board typically has only a USB-A port (HOST port).
⚠️ This CANNOT connect directly to Raspberry Pi via USB-to-USB cable!
⚠️ Instead, you must use the serial pins (TX, RX, GND) on the control board.

What Each Component Does:
--------------------------
USB-to-TTL Adapter:
  ✓ Connects to Raspberry Pi via USB (appears as /dev/ttyUSB0 on Linux)
  ✓ Provides TTL serial interface (TX, RX, GND pins)

Hiwonder Bus Servo Control Board:
  ✓ Receives serial commands via TX/RX pins
  ✓ Power regulation and distribution to servos
  ✓ Protocol conversion and signal management
  ✓ Protection circuitry

What hiwonder_hwi.py Does:
---------------------------
✓ Opens the serial port (/dev/ttyUSB0) created by the USB-to-TTL adapter
✓ Sends Hiwonder/LewanSoul protocol commands through the adapter to the control board
✓ The control board passes commands to servos (transparent pass-through)

This is different from Feetech servos (which have a USB device port on their control board).

Important: This guide covers connection via USB-to-TTL adapter + control board serial pins.
Direct GPIO UART connection is NOT recommended and NOT covered in this guide.

================================================================================
2. WHERE TO RUN SCRIPTS (PC vs Raspberry Pi)
================================================================================

You have TWO options depending on what you're doing:

Option A: Initial Testing on PC (Recommended First)
----------------------------------------------------
Setup:
    PC (Linux/macOS/Windows)
      ↓ USB cable
    USB-to-TTL Adapter (CP2102, FT232, CH340)
      ↓ Serial wires (TX, RX, GND)
    Hiwonder Bus Servo Control Board (serial pins)
      ↓ Servo connectors
    Hiwonder Servos (daisy-chained)
      ↓ External power supply (6-8.4V)

When to use:
- Initial servo testing and configuration
- Changing servo IDs
- Finding offsets
- Debugging servo issues

Requirements on PC:
- Python 3.7+
- PySerial: pip install pyserial
- USB-to-TTL adapter (CP2102, FT232RL, CH340G, etc.)
- Hiwonder Bus Servo Control Board
- External power supply for servos (6-8.4V)

Option B: On Raspberry Pi with USB-to-TTL Adapter (For Integration)
---------------------------------------------------------------------
Setup:
    Raspberry Pi
      ↓ USB cable
    USB-to-TTL Adapter (CP2102, FT232, CH340)
      ↓ Serial wires (TX, RX, GND)
    Hiwonder Bus Servo Control Board (serial pins)
      ↓ Servo connectors
    Hiwonder Servos
      ↓ External power supply (6-8.4V)

When to use:
- After initial configuration on PC
- Integrating with Duck Mini walking system
- Running the full robot

Requirements on Raspberry Pi:
- Same Python packages as PC
- SSH access (or screen/keyboard)
- USB-to-TTL adapter (CP2102, FT232RL, CH340G, etc.)
- Hiwonder Bus Servo Control Board
- No Bluetooth disabling needed (USB connection doesn't conflict)

Option C: On Raspberry Pi with GPIO UART (Temporary Alternative)
-----------------------------------------------------------------
Setup:
    Raspberry Pi GPIO Pins (14 & 15)
      ↓ Direct wiring (TX, RX, GND)
    Hiwonder Bus Servo Control Board (serial pins)
      ↓ Servo connectors
    Hiwonder Servos
      ↓ External power supply (6-8.4V)

When to use:
- When you don't have a USB-to-TTL adapter temporarily
- For quick testing without additional hardware
- TEMPORARY solution only

Requirements on Raspberry Pi:
- Enable UART via raspi-config
- DISABLE Bluetooth (required for GPIO UART)
- ⚠️ Xbox controller won't work over Bluetooth
- Jumper wires to connect GPIO pins to control board
- Port will be /dev/serial0 or /dev/ttyAMA0

⚠️ WARNING: This option disables Bluetooth, which means:
   - Xbox controller cannot connect via Bluetooth
   - You'll need a USB Xbox controller or wait for a USB-to-TTL adapter
   - Recommended ONLY as a temporary solution

================================================================================
3. PHASE 1: INITIAL SETUP ON PC ⭐ (EASIER FOR TESTING)
================================================================================

Step 1: Connect Hardware
------------------------
You need three main components:
  a) USB-to-TTL adapter (CP2102, FT232RL, CH340G, etc.)
  b) Hiwonder Bus Servo Control Board
  c) Hiwonder servos

Connection sequence:

1. **Connect USB-to-TTL Adapter to Control Board Serial Pins:**
   - Adapter TX → Control Board RX pin
   - Adapter RX → Control Board TX pin
   - Adapter GND → Control Board GND pin
   - Do NOT connect 5V/VCC between adapter and control board

2. **Connect Servos to Control Board:**
   - Plug servos into control board's servo connectors (can daisy-chain multiple servos)

3. **Connect Power Supply to Control Board:**
   - Connect external 6-8.4V power supply to control board
   ⚠️ IMPORTANT: Do NOT power servos from USB 5V - always use external 6-8.4V power supply!

4. **Connect USB-to-TTL Adapter to PC:**
   - Plug the adapter into your PC's USB port

⚠️ KEY POINT: The control board's USB-A port is NOT used. Use the serial pins (TX, RX, GND)!

Step 2: Find the Serial Port
-----------------------------
The USB-to-TTL adapter will appear as a USB serial device on your PC.

On Linux/macOS:
    ls /dev/tty* | grep -E "USB|ACM"
    # Typically shows: /dev/ttyUSB0 (most common for CP2102, CH340)
    #                  /dev/ttyUSB1 (if you have multiple USB serial devices)
    # FT232 might show as /dev/ttyUSB0 or /dev/cu.usbserial-XXXXXX on macOS

On Windows:
    1. Open Device Manager
    2. Go to: Ports (COM & LPT)
    3. Look for: USB Serial Port (COM3, COM4, etc.)
    4. The port name depends on which adapter you're using:
       - CP2102: "Silicon Labs CP210x USB to UART Bridge (COMX)"
       - CH340: "USB-SERIAL CH340 (COMX)"
       - FT232: "USB Serial Port (COMX)"

Step 3: Install PySerial (if not already installed)
----------------------------------------------------
    pip install pyserial

Step 4: Test Connection
------------------------
Run this command to verify servos are responding:

    python3 -c "from mini_bdx_runtime.hiwonder_hwi import HiwonderServo; \
    s = HiwonderServo('/dev/ttyUSB0'); \
    print('Found servos:', s.scan_servos(max_id=10)); \
    s.close()"

    Expected output: Found servos: [1]  (or whatever IDs are connected)

⚠️ If you see "Found servos: []", check:
   - Power supply is connected and turned on
   - USB cable is properly connected
   - Port name is correct (/dev/ttyUSB0 or your specific port)

Step 5: Configure Servo IDs (ONE SERVO AT A TIME!)
---------------------------------------------------
⚠️ IMPORTANT: Connect only ONE servo at a time to avoid ID conflicts!

Brand new Hiwonder servos have default ID = 1

For Servo 1:
    python3 scripts/configure_hiwonder_motor.py --port /dev/ttyUSB0 --id 100

    # The script will:
    # 1. Find the servo (tries ID 1 first, then scans)
    # 2. Show current status (position, voltage, temperature)
    # 3. Test movement
    # 4. Change ID to 100
    # 5. Verify the change worked

Unplug Servo 1, plug in Servo 2:
    python3 scripts/configure_hiwonder_motor.py --port /dev/ttyUSB0 --id 101

Repeat for each servo:
    python3 scripts/configure_hiwonder_motor.py --port /dev/ttyUSB0 --id 102
    python3 scripts/configure_hiwonder_motor.py --port /dev/ttyUSB0 --id 103
    # etc.

ID Convention Recommendations:
- Feetech servos: 10-33 (existing in your Duck Mini)
- Hiwonder servos: 100-199 (to avoid conflicts)
- Broadcast ID: 254 (don't use - affects all servos)

Step 6: Edit Code Configuration
--------------------------------
Now connect ALL your configured servos and update the code:

1. Open: mini_bdx_runtime/mini_bdx_runtime/hiwonder_hwi.py

2. Find the __init__ method in HiwonderHWI class (around line 210)

3. Update self.joints dictionary with your servo IDs:

    self.joints = {
        "hiwonder_joint_1": 100,  # Your first Hiwonder servo
        "hiwonder_joint_2": 101,  # Your second Hiwonder servo
        "hiwonder_joint_3": 102,  # Add more as needed
    }

4. Update self.init_pos with standing positions (in radians):

    self.init_pos = {
        "hiwonder_joint_1": 0.0,      # Example: straight (0°)
        "hiwonder_joint_2": 0.524,    # Example: 30°
        "hiwonder_joint_3": -0.349,   # Example: -20°
    }

    Note: Radians = Degrees × (π/180)
          30° = 0.524 rad
          45° = 0.785 rad
          90° = 1.571 rad

Step 7: Check All Servos
-------------------------
Verify all configured servos are responding:

    python3 scripts/check_hiwonder_motors.py

    When prompted:
    - Enter serial port: /dev/ttyUSB0 (or your port)

    The script will:
    ✓ Scan for all servos on the bus
    ✓ Check each configured joint from your code
    ✓ Read position, voltage, temperature for each
    ✓ Optionally test movement for each servo

Step 8: Calibrate Mechanical Offsets
-------------------------------------
⚠️ MOST IMPORTANT STEP! This compensates for mechanical assembly variations.

    python3 scripts/find_hiwonder_offsets.py

    When prompted:
    - Enter serial port: /dev/ttyUSB0 (or your port)
    - Confirm you want to continue (servos will move!)

    For EACH servo:
    1. Script moves servo to center position (500 units)
    2. Script turns off servo torque
    3. ⭐ YOU manually move the servo to the mechanically correct ZERO position
       (This is where the joint should be at 0° for your robot's geometry)
    4. Press Enter
    5. Script calculates the offset
    6. Script writes offset to servo's EEPROM (persistent storage)
    7. Script tests the result - verify it looks correct!
    8. Confirm (y) or retry (n)

    Example output at the end:

    Calculated offsets:
      hiwonder_joint_1: -15
      hiwonder_joint_2: 23
      hiwonder_joint_3: 0

    For duck_config.json (optional software offsets in radians):
    "joints_offsets": {
        "hiwonder_joint_1": -0.0628,
        "hiwonder_joint_2": 0.0963,
        "hiwonder_joint_3": 0.0000,
    }

    ✓ Offsets are now stored in servo EEPROM - they'll remember even after power off!
    ✓ You can also add software offsets in duck_config.json if needed later

Step 9: Final Test on PC
-------------------------
Run the built-in test to verify everything works:

    python3 -m mini_bdx_runtime.hiwonder_hwi

    This will:
    - Scan for servos
    - Test movement on the first servo found
    - Read diagnostics (voltage, temperature)

✅ If everything works, you're ready to move to Raspberry Pi!

================================================================================
4. PHASE 2: INTEGRATION ON RASPBERRY PI
================================================================================

Step 1: Transfer Files to Raspberry Pi
---------------------------------------
Option A: Using git (if you committed changes):

    # On PC - commit your configuration
    git add mini_bdx_runtime/mini_bdx_runtime/hiwonder_hwi.py
    git commit -m "Configure Hiwonder servo IDs and init positions"
    git push

    # On Raspberry Pi - pull changes
    ssh pi@<raspberry_pi_ip>
    cd ~/Open_Duck_Mini_Runtime
    git pull

Option B: Using scp (if you haven't committed):

    # From PC - copy files to Pi
    scp -r mini_bdx_runtime pi@<pi-ip>:~/Open_Duck_Mini_Runtime/
    scp -r scripts pi@<pi-ip>:~/Open_Duck_Mini_Runtime/

Step 2: Connect Hardware to Raspberry Pi
-----------------------------------------
1. Unplug USB-to-TTL adapter from PC
2. Plug the adapter into Raspberry Pi USB port
3. Keep the serial wires connected (Adapter TX/RX/GND → Control Board RX/TX/GND)
4. Keep external power supply (6-8.4V) connected to control board
5. Servos should still be connected (daisy-chained)
6. The adapter will appear as /dev/ttyUSB0 on the Raspberry Pi (same as on PC)

⚠️ Remember: The entire chain moves to the Pi together:
   - USB-to-TTL adapter plugs into Pi
   - Adapter stays wired to control board serial pins
   - Control board stays connected to servos
   - Power supply stays connected to control board

Step 3: Test Connection on Pi
------------------------------
SSH into your Raspberry Pi:

    ssh pi@<raspberry_pi_ip>
    cd ~/Open_Duck_Mini_Runtime

Test that Pi can see the servos:

    python3 -c "from mini_bdx_runtime.hiwonder_hwi import HiwonderServo; \
    s = HiwonderServo('/dev/ttyUSB0'); \
    print('Found servos:', s.scan_servos(max_id=120)); \
    s.close()"

    Expected: Found servos: [100, 101, 102, ...]  (your configured IDs)

Step 4: Check Servos on Pi
---------------------------
    python3 scripts/check_hiwonder_motors.py

    When prompted:
    - Enter serial port: /dev/ttyUSB0

    Verify all servos respond correctly

Step 5: Recalibrate Offsets (if needed)
----------------------------------------
If servos are now mounted on the robot in their final positions, you may need
to recalibrate the mechanical offsets:

    python3 scripts/find_hiwonder_offsets.py

    When prompted:
    - Enter serial port: /dev/ttyUSB0

    Follow the same calibration process as on PC

⚠️ Note: Only recalibrate if the mechanical zero position is different now
         that servos are mounted on the robot!

Step 6: Choose Integration Approach
------------------------------------
See HIWONDER_INTEGRATION.md for three options:

Option A: Standalone Feature (Recommended to start)
    - Use Hiwonder servos for a new feature independent of main locomotion
    - Example: tail, ears, additional expression features
    - Keep existing Feetech servos for legs and head

Option B: Hybrid Interface
    - Control both Feetech and Hiwonder servos simultaneously
    - Feetech motor control board on /dev/ttyACM0
    - Hiwonder Bus Servo Control Board on /dev/ttyUSB0
    - Requires creating hybrid_hwi.py (code provided in documentation)

Option C: Complete Replacement
    - Replace all Feetech servos with Hiwonder
    - Simple import change in v2_rl_walk_mujoco.py
    - Update joint naming to match existing convention

Step 7: Test Integration
-------------------------
Depending on your chosen approach:

For Standalone Feature:
    # Create your feature module
    # Add to duck_config.json
    # Test in isolation

For Hybrid or Replacement:
    # Update v2_rl_walk_mujoco.py
    # Test with walking policy
    python3 scripts/v2_rl_walk_mujoco.py --onnx_model_path <path>

================================================================================
5. PHASE 3: USING GPIO UART (TEMPORARY ALTERNATIVE) ⚠️
================================================================================

⚠️ IMPORTANT: This option is ONLY recommended if you don't have a USB-to-TTL adapter.
   It requires disabling Bluetooth, which will break Xbox controller functionality.

When to Use This Option:
------------------------
✓ You don't have a USB-to-TTL adapter yet
✓ You need to test Hiwonder servos immediately
✓ You have a USB Xbox controller (or don't need controller temporarily)

When NOT to Use This Option:
-----------------------------
✗ If you have or can get a USB-to-TTL adapter (~$2-5)
✗ If you need Bluetooth for Xbox controller
✗ For permanent installation (use USB-to-TTL adapter instead)

Step 1: Wire GPIO UART to Control Board
----------------------------------------
Connection diagram:

Raspberry Pi GPIO Header:
    Pin 1  [3.3V]     [5V]      Pin 2
    Pin 3  [GPIO 2]   [5V]      Pin 4
    Pin 5  [GPIO 3]   [GND] ←── Pin 6  (Connect to Control Board GND)
    Pin 7  [GPIO 4]   [GPIO 14 - TXD] ← Pin 8  (Connect to Control Board RX)
    Pin 9  [GND]      [GPIO 15 - RXD] ← Pin 10 (Connect to Control Board TX)

Physical connections:
1. Pi Pin 8 (GPIO 14, TXD) → Control Board RX pin
2. Pi Pin 10 (GPIO 15, RXD) → Control Board TX pin
3. Pi Pin 6 or 9 (GND) → Control Board GND pin
4. Do NOT connect 3.3V or 5V pins to control board
5. External 6-8.4V power supply → Control Board power input
6. Servos → Control Board servo connectors (daisy-chained)

⚠️ Use female-to-female jumper wires for connections

Step 2: Enable UART on Raspberry Pi
------------------------------------
SSH into your Raspberry Pi:

    ssh pi@<raspberry_pi_ip>
    cd ~/Open_Duck_Mini_Runtime

Enable serial hardware:

    sudo raspi-config

    # Navigate using arrow keys:
    # 3. Interface Options → I6 Serial Port
    # "Would you like a login shell accessible over serial?" → <No>
    # "Would you like the serial port hardware enabled?" → <Yes>
    # Select <Finish>, then reboot when prompted

Step 3: Disable Bluetooth (Required)
-------------------------------------
⚠️ THIS WILL DISABLE BLUETOOTH - Xbox controller won't work wirelessly!

Edit boot configuration:

    sudo nano /boot/config.txt

Scroll to the bottom and add these lines:

    # Disable Bluetooth to free up UART for Hiwonder servos
    dtoverlay=disable-bt
    enable_uart=1

Save and exit: Ctrl+X, then Y, then Enter

Disable Bluetooth services:

    sudo systemctl disable hciuart.service
    sudo systemctl disable bluetooth.service

Reboot to apply changes:

    sudo reboot

Step 4: Verify UART Port
-------------------------
After reboot, SSH back in and verify the serial port:

    ls -l /dev/serial*

    # Should show something like:
    # lrwxrwxrwx 1 root root 7 Jan 1 12:00 /dev/serial0 -> ttyAMA0
    # lrwxrwxrwx 1 root root 7 Jan 1 12:00 /dev/serial1 -> ttyS0

The port you'll use is: /dev/serial0

Also check:

    ls -l /dev/ttyAMA*

    # Should show: /dev/ttyAMA0

You can use either /dev/serial0 or /dev/ttyAMA0 (they point to the same device).

Step 5: Test Connection
-----------------------
Test that the Raspberry Pi can communicate with the control board:

    python3 -c "from mini_bdx_runtime.hiwonder_hwi import HiwonderServo; \
    s = HiwonderServo('/dev/serial0'); \
    print('Found servos:', s.scan_servos(max_id=10)); \
    s.close()"

Expected output:
    Found servos: [1] (or your configured IDs like [100, 101, 102])

If you see "Found servos: []":
✓ Check wiring (TX→RX, RX→TX, GND→GND)
✓ Try swapping TX and RX wires
✓ Verify power supply is connected to control board
✓ Check that servos are connected to control board

Step 6: Configure Servos Using GPIO UART
-----------------------------------------
Now you can run all the same scripts, but use /dev/serial0 instead of /dev/ttyUSB0:

Scan and read servo IDs:
    python3 scripts/configure_hiwonder_motor.py --port /dev/serial0
    # This will scan and display all connected servo IDs

Configure servo IDs (one at a time):
    python3 scripts/configure_hiwonder_motor.py --port /dev/serial0 --id 100
    # This will scan, find the servo, and change its ID to 100

Configure specific servo ID:
    python3 scripts/configure_hiwonder_motor.py --port /dev/serial0 --current-id 1 --id 100
    # This will change servo with ID 1 to ID 100

Check all servos:
    python3 scripts/check_hiwonder_motors.py
    # When prompted, enter: /dev/serial0

Calibrate offsets:
    python3 scripts/find_hiwonder_offsets.py
    # When prompted, enter: /dev/serial0

Step 7: Update Code for GPIO UART
----------------------------------
If integrating with the main walking system, you'll need to specify the port.

For hybrid interface (mini_bdx_runtime/hybrid_hwi.py):

    # Change this line:
    self.hiwonder = HiwonderHWI(duck_config, usb_port="/dev/ttyUSB0")

    # To this:
    self.hiwonder = HiwonderHWI(duck_config, usb_port="/dev/serial0")

Or when running standalone:

    from mini_bdx_runtime.hiwonder_hwi import HiwonderHWI
    hwi = HiwonderHWI(duck_config, usb_port="/dev/serial0")

Step 8: Re-enabling Bluetooth (When You Get USB-to-TTL Adapter)
----------------------------------------------------------------
When you eventually get a USB-to-TTL adapter, you'll want to re-enable Bluetooth:

1. Disconnect GPIO wires from Pi (but keep control board and servos together)
2. Connect USB-to-TTL adapter:
   - Adapter → Pi USB port
   - Adapter TX/RX/GND → Control Board RX/TX/GND (same as before)

3. Re-enable Bluetooth:

    sudo nano /boot/config.txt

    # Comment out or remove these lines:
    # dtoverlay=disable-bt
    # enable_uart=1

    # Save and exit (Ctrl+X, Y, Enter)

4. Re-enable Bluetooth services:

    sudo systemctl enable hciuart.service
    sudo systemctl enable bluetooth.service

5. Reboot:

    sudo reboot

6. Update code to use /dev/ttyUSB0 instead of /dev/serial0

7. Test Xbox controller reconnects over Bluetooth:

    python3 mini_bdx_runtime/mini_bdx_runtime/xbox_controller.py

Summary of Port Changes:
-------------------------
GPIO UART (temporary):  /dev/serial0 or /dev/ttyAMA0
USB-to-TTL adapter:     /dev/ttyUSB0

================================================================================
6. PORT NAMES REFERENCE
================================================================================

Device                                  | Linux/Raspberry Pi    | Windows      | Notes
----------------------------------------|-----------------------|--------------|------------------
USB-to-TTL Adapter → Hiwonder Board     | /dev/ttyUSB0          | COM3, COM4   | Recommended method
CP2102/CH340/FT232                      | /dev/ttyUSB1          |              | (if multiple USB devices)
                                        |                       |              |
Raspberry Pi GPIO UART → Hiwonder Board | /dev/serial0          | N/A          | Temporary alternative
                                        | /dev/ttyAMA0          |              | Requires disabling Bluetooth
                                        |                       |              |
Feetech Motor Control Board             | /dev/ttyACM0          | COM#         | Your existing board
(has USB device port)                   |                       |              | (connects directly via USB)

How to Find Your Port:
----------------------
Linux/macOS:
    ls /dev/tty* | grep -E "USB|ACM"

    # Or with more detail:
    ls -l /dev/tty* | grep -E "USB|ACM"

Windows:
    1. Open Device Manager (Win+X, then M)
    2. Expand "Ports (COM & LPT)"
    3. Look for "USB Serial Port (COM#)"

Raspberry Pi specific:
    # For USB-to-TTL adapter:
    ls /dev/tty* | grep USB
    # USB-to-TTL adapter (for Hiwonder): Usually /dev/ttyUSB0
    # Feetech Motor Control Board: Usually /dev/ttyACM0

    # For GPIO UART:
    ls -l /dev/serial*
    # Should show: /dev/serial0 -> ttyAMA0 (or ttyS0)

    # Both can coexist:
    # /dev/ttyUSB0 → USB-to-TTL adapter → Hiwonder control board → Hiwonder servos
    # /dev/ttyACM0 → Feetech control board → Feetech servos

    # Or with GPIO UART (temporary):
    # /dev/serial0 → GPIO UART → Hiwonder control board → Hiwonder servos
    # /dev/ttyACM0 → Feetech control board → Feetech servos

================================================================================
7. QUICK TEST COMMANDS
================================================================================

Test on PC with USB-to-TTL Adapter (Linux/macOS):
--------------------------
    # Scan for servos
    python3 -c "from mini_bdx_runtime.hiwonder_hwi import HiwonderServo; \
    s = HiwonderServo('/dev/ttyUSB0'); \
    print('Found servos:', s.scan_servos(max_id=10)); \
    s.close()"

    # Test movement on servo ID 1
    python3 -c "from mini_bdx_runtime.hiwonder_hwi import HiwonderServo; \
    s = HiwonderServo('/dev/ttyUSB0'); \
    s.move_servo(1, 500, 1000); \
    import time; time.sleep(1.5); \
    print('Position:', s.read_position(1)); \
    s.close()"

Test on PC (Windows):
---------------------
    # Scan for servos (use your COM port)
    python -c "from mini_bdx_runtime.hiwonder_hwi import HiwonderServo; s = HiwonderServo('COM3'); print('Found servos:', s.scan_servos(max_id=10)); s.close()"

Test on Raspberry Pi with USB-to-TTL Adapter (via SSH):
--------------------------------------------------------
    ssh pi@<raspberry_pi_ip>

    # Scan for servos via USB-to-TTL adapter
    python3 -c "from mini_bdx_runtime.hiwonder_hwi import HiwonderServo; \
    s = HiwonderServo('/dev/ttyUSB0'); \
    print('Found servos:', s.scan_servos(max_id=120)); \
    s.close()"

Test on Raspberry Pi with GPIO UART (via SSH):
-----------------------------------------------
    ssh pi@<raspberry_pi_ip>

    # Scan for servos via GPIO UART
    python3 -c "from mini_bdx_runtime.hiwonder_hwi import HiwonderServo; \
    s = HiwonderServo('/dev/serial0'); \
    print('Found servos:', s.scan_servos(max_id=120)); \
    s.close()"

    # Alternative using ttyAMA0 directly
    python3 -c "from mini_bdx_runtime.hiwonder_hwi import HiwonderServo; \
    s = HiwonderServo('/dev/ttyAMA0'); \
    print('Found servos:', s.scan_servos(max_id=120)); \
    s.close()"

Built-in Hardware Test:
------------------------
    # Runs comprehensive test on first servo found
    python3 -m mini_bdx_runtime.hiwonder_hwi

Configuration Scripts:
----------------------
    # Scan and read all servo IDs (USB-to-TTL adapter)
    python3 scripts/configure_hiwonder_motor.py --port /dev/ttyUSB0

    # Scan and read all servo IDs (GPIO UART)
    python3 scripts/configure_hiwonder_motor.py --port /dev/serial0

    # Configure servo ID (USB-to-TTL adapter)
    python3 scripts/configure_hiwonder_motor.py --port /dev/ttyUSB0 --id 100

    # Configure servo ID (GPIO UART)
    python3 scripts/configure_hiwonder_motor.py --port /dev/serial0 --id 100

    # Configure specific servo (if multiple servos connected)
    python3 scripts/configure_hiwonder_motor.py --port /dev/ttyUSB0 --current-id 1 --id 100

    # Check all servos (will prompt for port)
    python3 scripts/check_hiwonder_motors.py
    # Enter: /dev/ttyUSB0 (for USB-to-TTL adapter)
    # OR
    # Enter: /dev/serial0 (for GPIO UART)

    # Calibrate offsets (will prompt for port)
    python3 scripts/find_hiwonder_offsets.py
    # Enter: /dev/ttyUSB0 (for USB-to-TTL adapter)
    # OR
    # Enter: /dev/serial0 (for GPIO UART)

================================================================================
8. TROUBLESHOOTING
================================================================================

Problem: "No servos found" / scan_servos returns []
----------------------------------------------------
Solutions:
✓ Check power supply is connected and turned on (6-8.4V)
✓ Verify USB-to-TTL adapter is properly connected to PC/Pi
✓ Check serial wiring between adapter and control board:
    - Adapter TX → Control Board RX
    - Adapter RX → Control Board TX
    - Adapter GND → Control Board GND
✓ Try a different USB port for the adapter
✓ Check port name is correct:
    Linux/macOS: ls /dev/tty* | grep USB
    Windows: Check Device Manager
✓ Try different baud rates (115200 is default, but some boards use 9600 or 38400)
✓ Try swapping TX/RX wires (TX↔RX) if still not working
✓ Try connecting only one servo to eliminate daisy-chain issues
✓ Verify the adapter has TX/RX LEDs blinking when commands are sent

Problem: "I connected the control board's USB-A port to Raspberry Pi but it doesn't work"
------------------------------------------------------------------------------------------
Answer:
⚠️ The USB-A port on the Hiwonder control board is a HOST port, not a device port
⚠️ It CANNOT be used to connect to a PC or Raspberry Pi
✓ You MUST use the serial pins (TX, RX, GND) on the control board
✓ Connect these pins to a USB-to-TTL adapter (CP2102, FT232, CH340)
✓ Then connect the adapter to your PC/Pi via USB
✓ See Step 1 in Phase 1 for detailed wiring instructions

Problem: "Permission denied" when opening /dev/ttyUSB0 (Linux)
---------------------------------------------------------------
Solutions:
✓ Add your user to dialout group:
    sudo usermod -a -G dialout $USER
    # Then log out and log back in

✓ Or run with sudo (not recommended):
    sudo python3 scripts/configure_hiwonder_motor.py --port /dev/ttyUSB0 --id 100

Problem: Servo moves but position is wrong / jittery
-----------------------------------------------------
Solutions:
✓ Calibrate offsets: python3 scripts/find_hiwonder_offsets.py
✓ Check voltage - low voltage causes poor performance
    - Should be 6.0-8.4V
    - Measure with multimeter at servo VCC pin
✓ Check mechanical load:
    - Hiwonder HTD-45H is relatively small (4.5kg-cm torque)
    - May not have enough torque for heavy joints
    - Consider HTD-35H or HTD-25H for lighter loads
✓ Increase movement duration:
    hwi.servo.move_servo(servo_id, position, duration=1000)  # 1 second

Problem: "Checksum error" messages
-----------------------------------
Solutions:
✓ Bad wiring or electrical noise
✓ Check all connections are tight
✓ Shorten cables if possible
✓ Add ferrite beads to cables
✓ Keep servo wires away from power wires
✓ Use shielded cable if available

Problem: Servo doesn't hold position / drifts
----------------------------------------------
Solutions:
✓ HTD-45H has less holding torque than Feetech servos
✓ For main locomotion joints, might need:
    - Higher control frequency
    - Load-appropriate servo selection
    - External mechanical support
✓ Check if torque is enabled:
    hwi.servo.load_servo(servo_id)

Problem: "ModuleNotFoundError: No module named 'mini_bdx_runtime'"
------------------------------------------------------------------
This means the Python package is not installed.

Solutions (choose ONE):

Option 1: Install with pip (traditional):
    cd ~/Open_Duck_Mini_Runtime
    pip install -e .

Option 2: Install with uv (faster, modern):
    cd ~/Open_Duck_Mini_Runtime
    # Install uv if not already installed:
    curl -LsSf https://astral.sh/uv/install.sh | sh

    # Install the package:
    uv pip install -e .

Option 3: Temporary fix (add to PYTHONPATH):
    cd ~/Open_Duck_Mini_Runtime
    export PYTHONPATH="${PYTHONPATH}:$(pwd)/mini_bdx_runtime"
    # Note: This only lasts for current terminal session

After installing, verify it works:
    python3 -c "import mini_bdx_runtime; print('Success!')"

Problem: Scripts work on PC but not on Raspberry Pi
----------------------------------------------------
Solutions:
✓ Port name might be different (check with ls /dev/tty*)
✓ PySerial might not be installed on Pi:
    pip install pyserial
✓ Check if running in correct virtual environment:
    workon open-duck-mini-runtime
✓ Make sure control board has power when connected to Pi

Problem: Do I need to disable Bluetooth on Raspberry Pi?
---------------------------------------------------------
Answer: IT DEPENDS on your connection method!

If using USB-to-TTL Adapter (Recommended):
✓ NO - Keep Bluetooth ENABLED
✓ USB serial ports (/dev/ttyUSB0) do NOT conflict with Bluetooth
✓ You NEED Bluetooth enabled for Xbox controller
✓ This is the recommended permanent solution

If using GPIO UART (Temporary):
✓ YES - You MUST disable Bluetooth
✓ GPIO UART (/dev/serial0, /dev/ttyAMA0) conflicts with Bluetooth
✓ Follow Phase 3 instructions to disable Bluetooth properly
✓ Xbox controller won't work wirelessly (need USB Xbox controller)
✓ Only use this as a temporary solution

Problem: GPIO UART not working / Permission denied on /dev/serial0
-------------------------------------------------------------------
Solutions:
✓ Check if UART is enabled:
    ls -l /dev/serial*
    # Should show /dev/serial0 symlink
✓ Enable UART via raspi-config (see Phase 3, Step 2)
✓ Check if Bluetooth is disabled (required):
    sudo systemctl status bluetooth
    # Should show: "Loaded: loaded (...; disabled; ...)"
✓ Verify boot config:
    grep -E "dtoverlay=disable-bt|enable_uart" /boot/config.txt
    # Should show both lines uncommented
✓ Reboot after making changes:
    sudo reboot
✓ Add user to dialout group:
    sudo usermod -a -G dialout $USER
    # Then log out and log back in

Problem: GPIO UART shows "No servos found" but wiring looks correct
--------------------------------------------------------------------
Solutions:
✓ Try swapping TX and RX wires
    - Pi GPIO 14 should go to Control Board RX
    - Pi GPIO 15 should go to Control Board TX
    - If backwards, swap them
✓ Verify GND connection is solid
✓ Check control board has power (6-8.4V)
✓ Try a different GPIO GND pin (Pin 6, 9, 14, 20, 25, 30, 34, or 39)
✓ Test with multimeter: measure voltage between Pi 3.3V pin and GND (should be 3.3V)
✓ Verify servos work by testing on PC first with USB-to-TTL adapter

Problem: Velocity observations are all zeros
---------------------------------------------
This is expected!
✓ Hiwonder servos do NOT provide velocity feedback
✓ get_present_velocities() returns zeros by design
✓ If your RL policy needs velocity:
    - Estimate from position changes (diff/dt)
    - Use differentiator filter
    - Or retrain policy without velocity observations

Problem: Control loop too slow (exceeds 20ms budget)
-----------------------------------------------------
Solutions:
✓ Don't read all servos every frame
✓ Read servos in rotation (round-robin):
    Frame 1: Read servos 100-102
    Frame 2: Read servos 103-105
    Frame 3: Read servos 100-102 (repeat)
✓ Increase control loop period (lower frequency):
    control_freq = 25  # Hz instead of 50
✓ Implement bulk read commands (future enhancement)

================================================================================
9. RECOMMENDATIONS
================================================================================

Best Approach: Start on PC First
---------------------------------
Why?
✓ Easier to debug (no SSH needed)
✓ Faster to edit code and test
✓ Can test servos before mounting on robot
✓ Better error messages visible directly

The servos and control board remember their configuration:
✓ Servo IDs stored in EEPROM (persistent)
✓ Servo offsets stored in EEPROM (persistent)
✓ Once configured on PC, just plug the control board into Pi - it works the same!

Connection Method Recommendations
----------------------------------
✓ The control board's USB-A port is NOT used (it's a host port, not device port)
✓ You must use the serial pins (TX, RX, GND) on the control board
✓ Two options: USB-to-TTL adapter (recommended) OR GPIO UART (temporary)

Option 1: USB-to-TTL Adapter (RECOMMENDED for permanent use)
-------------------------------------------------------------
✓ Recommended for permanent installation
✓ Keeps Bluetooth enabled (Xbox controller works)
✓ Clean, reliable connection
✓ Easy to disconnect and reconnect
✓ No Pi configuration changes needed
✓ USB-to-TTL adapters are cheap (~$2-5) and widely available
✓ Recommended adapters: CP2102, FT232RL, CH340G
✓ Port: /dev/ttyUSB0

Option 2: GPIO UART (TEMPORARY alternative)
--------------------------------------------
✓ Use ONLY if you don't have a USB-to-TTL adapter
✓ Requires disabling Bluetooth (breaks Xbox controller)
✓ Direct wiring to GPIO pins 14 & 15
✓ Requires Pi configuration (raspi-config + boot config)
✓ More prone to wiring errors
✓ Only recommended as temporary solution until you get adapter
✓ Port: /dev/serial0 or /dev/ttyAMA0

Hardware Shopping List:
-----------------------
For USB-to-TTL Method (Recommended):
✓ USB-to-TTL adapter with 3.3V/5V TTL levels (CP2102, FT232RL, or CH340G)
✓ Hiwonder Bus Servo Control Board (you already have this)
✓ Hiwonder HTD-45H servos
✓ External 6-8.4V power supply for servos
✓ Jumper wires (female-to-female) to connect adapter to control board serial pins

For GPIO UART Method (Temporary):
✓ Hiwonder Bus Servo Control Board (you already have this)
✓ Hiwonder HTD-45H servos
✓ External 6-8.4V power supply for servos
✓ Female-to-female jumper wires (3 wires: TX, RX, GND)
✓ USB Xbox controller (since Bluetooth will be disabled)

Workflow Summary:
-----------------
1. [PC] Configure servo IDs (one at a time)
2. [PC] Update code (self.joints, self.init_pos)
3. [PC] Test all servos together
4. [PC] Do initial offset calibration
5. [Transfer] Move files to Raspberry Pi
6. [Pi] Connect control board to Pi
7. [Pi] Test servos respond correctly
8. [Pi] Recalibrate offsets if servos are now mounted on robot
9. [Pi] Integrate with Duck Mini system

ID Convention:
--------------
Feetech (existing):
  - Left leg: 20-24 (hip_yaw, hip_roll, hip_pitch, knee, ankle)
  - Right leg: 10-14 (hip_yaw, hip_roll, hip_pitch, knee, ankle)
  - Head: 30-33 (neck_pitch, head_pitch, head_yaw, head_roll)

Hiwonder (recommended):
  - Use 100-199 range to avoid conflicts
  - Example: 100, 101, 102, 103, etc.

Never use:
  - ID 0 (reserved)
  - ID 254 (broadcast - affects all servos)
  - IDs 10-33 (conflicts with Feetech)

Position Units:
---------------
Hiwonder native: 0-1000 (500 = center, 240° total range)
  - 0 units = -120° (left limit)
  - 500 units = 0° (center)
  - 1000 units = +120° (right limit)
  - 1 unit ≈ 0.24° or 0.004189 radians

The interface converts automatically to radians:
  - You work in radians everywhere
  - hiwonder_hwi.py handles conversion internally

Calibration Notes:
------------------
✓ Hardware offsets (EEPROM) are persistent across power cycles
✓ EEPROM has limited write cycles (~100,000)
✓ Don't recalibrate unnecessarily
✓ Software offsets in duck_config.json can supplement hardware offsets
✓ Calibrate with servos in final mounted position on robot

Performance Notes:
------------------
✓ Reading position: ~5ms per servo
✓ 10 servos = 50ms (exceeds 20ms budget for 50Hz control)
✓ Plan accordingly - don't read all servos every frame
✓ Consider lower control frequency if using many Hiwonder servos
✓ No velocity feedback - returns zeros

Safety Notes:
-------------
⚠️ Always have emergency stop ready (Ctrl+C or power switch)
⚠️ Test new servos with low power first
⚠️ Start with small movements and slow speeds
⚠️ Never power servos from USB 5V - use external 6-8.4V supply
⚠️ Disconnect power when not testing
⚠️ Mount servos securely before running at full power

================================================================================
QUICK REFERENCE CHECKLIST
================================================================================

☐ Hardware Setup (choose ONE connection method):

  Option A: USB-to-TTL Adapter (Recommended):
  ☐ USB-to-TTL adapter connected to PC/Pi via USB
  ☐ Adapter serial pins (TX, RX, GND) wired to control board serial pins
  ☐ External 6-8.4V power supply connected to control board
  ☐ Servos connected to control board's servo connectors (daisy-chained)
  ☐ All connections secure (check TX→RX, RX→TX, GND→GND)
  ☐ Control board's USB-A port is NOT used
  ☐ Bluetooth enabled on Pi (needed for Xbox controller)
  ☐ Port will be: /dev/ttyUSB0

  Option B: GPIO UART (Temporary):
  ☐ Pi GPIO 14 (Pin 8) wired to Control Board RX
  ☐ Pi GPIO 15 (Pin 10) wired to Control Board TX
  ☐ Pi GND (Pin 6 or 9) wired to Control Board GND
  ☐ External 6-8.4V power supply connected to control board
  ☐ Servos connected to control board's servo connectors (daisy-chained)
  ☐ Control board's USB-A port is NOT used
  ☐ UART enabled via raspi-config
  ☐ Bluetooth DISABLED on Pi (required for GPIO UART)
  ☐ dtoverlay=disable-bt and enable_uart=1 in /boot/config.txt
  ☐ Port will be: /dev/serial0 or /dev/ttyAMA0

☐ Software Setup:
  ☐ PySerial installed: pip install pyserial
  ☐ Port identified (see connection method above)
  ☐ Scripts executable: ls scripts/configure_hiwonder_motor.py

☐ Configuration (one servo at a time!):
  ☐ Servo 1: ID 100 configured and tested
  ☐ Servo 2: ID 101 configured and tested
  ☐ Servo 3: ID 102 configured and tested
  ☐ (Repeat for all servos)

☐ Code Update:
  ☐ mini_bdx_runtime/mini_bdx_runtime/hiwonder_hwi.py edited
  ☐ self.joints updated with servo IDs
  ☐ self.init_pos updated with standing positions

☐ Testing:
  ☐ All servos respond: python3 scripts/check_hiwonder_motors.py
  ☐ Movement test passed for each servo
  ☐ Voltage readings look good (6-8.4V range)
  ☐ Temperature readings normal (<60°C)

☐ Calibration:
  ☐ Offsets calibrated: python3 scripts/find_hiwonder_offsets.py
  ☐ Each servo tested after offset applied
  ☐ Results look mechanically correct

☐ Integration:
  ☐ Integration approach chosen (A, B, or C)
  ☐ Code changes made according to approach
  ☐ Testing with full system successful

================================================================================
NEXT STEPS
================================================================================

After completing this guide:

1. Review HIWONDER_INTEGRATION.md for detailed integration options
2. Review CLAUDE.md for overall project architecture
3. Test your specific integration approach
4. Adjust PID gains if needed (see rustypot_position_hwi.py for reference)
5. Consider adding safety limits in code
6. Document any project-specific configurations

For Additional Help:
--------------------
- HIWONDER_INTEGRATION.md - Complete integration guide with code examples
- CLAUDE.md - Project architecture and development workflow
- scripts/configure_hiwonder_motor.py --help - Command line options
- Hiwonder documentation: https://www.hiwonder.com/
- LewanSoul protocol: https://github.com/ccourson/LX-16A-Servo

================================================================================
END OF SETUP GUIDE
================================================================================
